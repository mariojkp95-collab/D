<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NosTale Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            touch-action: none; /* Prevent scrolling on mobile */
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        #gameCanvas {
            display: block;
            background: #2d4a2b;
            cursor: crosshair;
            touch-action: none;
        }

        /* HUD Elements - Mobile Landscape Optimized */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Mobile-First Player Info Panel - Top Left Corner */
        #playerPanel {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.75);
            border: 1px solid #4a90e2;
            border-radius: 6px;
            padding: 6px 8px;
            color: white;
            min-width: 140px;
            font-size: 11px;
            backdrop-filter: blur(4px);
        }

        /* Compact Health/Mana Bars for Mobile */
        .health-bar, .mana-bar {
            width: 120px;
            height: 8px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            margin: 2px 0;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ee5a52);
            border-radius: 3px;
            transition: width 0.3s ease;
            box-shadow: 0 0 4px rgba(255, 107, 107, 0.3);
        }

        .mana-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #45b7b8);
            border-radius: 3px;
            transition: width 0.3s ease;
            box-shadow: 0 0 4px rgba(78, 205, 196, 0.3);
        }

        /* Compact Target Panel - Top Right */
        #targetPanel {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.75);
            border: 1px solid #e74c3c;
            border-radius: 6px;
            padding: 6px 8px;
            color: white;
            min-width: 120px;
            font-size: 11px;
            display: none;
            backdrop-filter: blur(4px);
        }

        /* Mobile-Optimized Action Bar - Hidden on Mobile */
        #actionBar {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #4a90e2;
            border-radius: 8px;
            padding: 6px 8px;
            display: none; /* Hidden by default, shown only on desktop */
            gap: 4px;
            align-items: center;
        }

        .skill-slot {
            width: 36px;
            height: 36px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }

        .skill-slot:hover, .skill-slot:active {
            border-color: #4a90e2;
            background: rgba(74, 144, 226, 0.3);
            transform: scale(1.05);
        }

        .skill-slot.selected {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.4);
        }

        /* Mobile-Optimized Chat Panel - Minimized by default */
        #chatPanel {
            position: absolute;
            bottom: 60px;
            left: 8px;
            width: 280px;
            height: 80px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #333;
            border-radius: 6px;
            overflow: hidden;
            font-size: 10px;
            backdrop-filter: blur(2px);
            pointer-events: auto;
        }

        #chatMessages {
            height: 90px;
            overflow-y: auto;
            padding: 5px;
            color: white;
            font-size: 12px;
        }

        #chatInput {
            width: 100%;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            padding: 5px;
            color: white;
            outline: none;
        }

        #chatInput::placeholder {
            color: #aaa;
        }

        /* Notifications */
        .notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 18px;
            z-index: 1000;
            animation: fadeInOut 3s ease-in-out;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20%, 80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        .notification.error { border-left: 4px solid #ff4757; }
        .notification.success { border-left: 4px solid #2ed573; }
        .notification.info { border-left: 4px solid #4a90e2; }
        .notification.warning { border-left: 4px solid #ffa726; }

        /* Mobile Controls */
        #mobileControls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none;
            z-index: 20;
        }

        /* Mobile Landscape Joystick - Left Thumb Zone */
        #joystick {
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.02) 70%);
            border: 2px solid rgba(255, 255, 255, 0.25);
            border-radius: 50%;
            position: relative;
            touch-action: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        #joystickKnob {
            width: 32px;
            height: 32px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.7) 100%);
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.08s ease-out;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        /* Mobile Action Buttons - Right Thumb Zone Layout */
        #mobileActionButtons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: none;
            z-index: 20;
        }

        /* Primary Action Button (Attack/Interact) - Most accessible position */
        .mobile-btn-primary {
            width: 70px;
            height: 70px;
            background: radial-gradient(circle, rgba(255, 59, 59, 0.9) 0%, rgba(231, 76, 60, 0.8) 100%);
            border: 2px solid #e74c3c;
            border-radius: 50%;
            color: white;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            position: absolute;
            bottom: 0;
            right: 0;
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
            transition: all 0.1s ease;
        }

        .mobile-btn-primary:active {
            transform: scale(0.95);
            box-shadow: 0 2px 6px rgba(231, 76, 60, 0.6);
        }

        /* Secondary Action Button (Space/Select) */
        .mobile-btn-secondary {
            width: 55px;
            height: 55px;
            background: radial-gradient(circle, rgba(74, 144, 226, 0.9) 0%, rgba(52, 152, 219, 0.8) 100%);
            border: 2px solid #3498db;
            border-radius: 50%;
            color: white;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
            user-select: none;
            position: absolute;
            bottom: 75px;
            right: 15px;
            box-shadow: 0 3px 10px rgba(52, 152, 219, 0.4);
            transition: all 0.1s ease;
        }

        .mobile-btn-secondary:active {
            transform: scale(0.95);
            box-shadow: 0 2px 6px rgba(52, 152, 219, 0.6);
        }

        .mobile-btn:active {
            background: rgba(74, 144, 226, 1);
            transform: scale(0.95);
        }

        /* Mobile Landscape Optimizations */
        @media (max-width: 768px) and (orientation: landscape), 
               (max-height: 500px) {
            
            /* Show mobile controls in landscape mode */
            #mobileControls, #mobileActionButtons {
                display: block !important;
            }

            /* Hide desktop action bar on mobile */
            #actionBar {
                display: none !important;
            }
            
            /* Adjust player panel for landscape */
            #playerPanel {
                top: 5px;
                left: 5px;
                padding: 4px 6px;
                min-width: 110px;
                font-size: 10px;
            }

            .health-bar, .mana-bar {
                width: 100px;
                height: 6px;
                margin: 1px 0;
            }

            /* Adjust target panel for landscape */
            #targetPanel {
                top: 5px;
                right: 5px;
                padding: 4px 6px;
                min-width: 100px;
                font-size: 10px;
            }
            
            /* Compact chat panel for landscape */
            #chatPanel {
                width: 220px;
                height: 60px;
                bottom: 40px;
                left: 5px;
                font-size: 9px;
            }
            
            /* Position joystick in left thumb zone */
            #mobileControls {
                bottom: 25px !important;
                left: 25px !important;
            }

            /* Ensure action buttons are in right thumb zone */
            #mobileActionButtons {
                bottom: 25px !important;
                right: 25px !important;
            }

            /* Hide unnecessary elements on small screens */
            .desktop-only {
                display: none !important;
            }
        }

        /* Portrait mode adjustments (discourage but support) */
        @media (max-width: 768px) and (orientation: portrait) {
            #gameCanvas {
                height: 60vh; /* Reduce canvas size in portrait */
            }

            #mobileControls, #mobileActionButtons {
                display: block !important;
            }

            #actionBar {
                display: none !important;
            }

            /* Add orientation hint */
            body::before {
                content: "🔄 Ruota il dispositivo in orizzontale per un'esperienza migliore";
                position: fixed;
                top: 10px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(255, 193, 7, 0.9);
                color: #000;
                padding: 8px 12px;
                border-radius: 20px;
                font-size: 12px;
                z-index: 1000;
                text-align: center;
                font-weight: bold;
            }
        }

        /* Desktop optimizations */
        @media (min-width: 769px) {
            /* Show desktop action bar */
            #actionBar {
                display: flex !important;
            }

            /* Hide mobile controls on desktop */
            #mobileControls, #mobileActionButtons {
                display: none !important;
            }

            /* Larger UI elements on desktop */
            #playerPanel, #targetPanel {
                min-width: 180px;
                font-size: 12px;
                padding: 8px 10px;
            }

            .health-bar, .mana-bar {
                width: 140px;
                height: 10px;
            }

            #chatMessages {
                height: 70px;
            }
        }

        /* Mobile-Friendly Inventory System */
        #inventoryPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 90vw;
            max-width: 400px;
            height: 60vh;
            max-height: 500px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #4a90e2;
            border-radius: 12px;
            z-index: 100;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
        }

        #inventoryPanel.show {
            display: flex;
            transform: translate(-50%, -50%) scale(1);
        }

        .inventory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(74, 144, 226, 0.2);
            border-radius: 10px 10px 0 0;
            color: white;
            font-weight: bold;
        }

        .close-btn {
            background: none;
            border: none;
            color: white;
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s ease;
        }

        .close-btn:hover, .close-btn:active {
            background: rgba(255, 255, 255, 0.2);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            padding: 16px;
            overflow-y: auto;
            flex: 1;
        }

        .inventory-slot {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #333;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 60px;
            touch-action: manipulation;
        }

        .inventory-slot:hover, .inventory-slot:active {
            border-color: #4a90e2;
            background: rgba(74, 144, 226, 0.2);
            transform: scale(1.05);
        }

        .inventory-slot.has-item {
            border-color: #2ed573;
            background: rgba(46, 213, 115, 0.1);
        }

        .item-icon {
            font-size: 24px;
            pointer-events: none;
        }

        .item-quantity {
            position: absolute;
            bottom: 2px;
            right: 4px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 3px;
            min-width: 12px;
            text-align: center;
        }

        /* Mini-Map System */
        #miniMap {
            position: fixed;
            top: 8px;
            right: 140px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #4a90e2;
            border-radius: 8px;
            z-index: 15;
            overflow: hidden;
            display: block;
        }

        #miniMapCanvas {
            width: 100%;
            height: 100%;
            cursor: pointer;
            touch-action: manipulation;
        }

        /* Settings Menu */
        #settingsPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 90vw;
            max-width: 350px;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #4a90e2;
            border-radius: 12px;
            z-index: 100;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
            max-height: 70vh;
        }

        #settingsPanel.show {
            display: flex;
            transform: translate(-50%, -50%) scale(1);
        }

        .settings-content {
            padding: 16px;
            color: white;
            overflow-y: auto;
            flex: 1;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group h3 {
            color: #4a90e2;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-toggle {
            width: 48px;
            height: 24px;
            background: #333;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .setting-toggle.active {
            background: #4a90e2;
        }

        .setting-toggle::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.3s ease;
        }

        .setting-toggle.active::after {
            transform: translateX(24px);
        }

        .setting-slider {
            width: 100px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .setting-slider-fill {
            height: 100%;
            background: #4a90e2;
            border-radius: 2px;
            width: 50%;
            position: relative;
        }

        .setting-slider-thumb {
            position: absolute;
            right: -6px;
            top: -4px;
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
        }

        /* Enhanced Chat System */
        .chat-tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px 4px 0 0;
            overflow: hidden;
        }

        .chat-tab {
            flex: 1;
            padding: 4px 8px;
            background: none;
            border: none;
            color: #aaa;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chat-tab.active {
            background: rgba(74, 144, 226, 0.3);
            color: white;
        }

        /* UI Toggle Buttons */
        .ui-toggle-btn {
            position: fixed;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #4a90e2;
            border-radius: 50%;
            color: white;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 20;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }

        .ui-toggle-btn:hover, .ui-toggle-btn:active {
            background: rgba(74, 144, 226, 0.8);
            transform: scale(1.1);
        }

        #inventoryBtn {
            top: 60px;
            right: 8px;
        }

        #settingsBtn {
            top: 110px;
            right: 8px;
        }

        #guildBtn {
            top: 160px;
            right: 8px;
        }

        /* Guild Panel */
        #guildPanel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            width: 90vw;
            max-width: 450px;
            height: 70vh;
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #ffd700;
            border-radius: 12px;
            z-index: 100;
            display: none;
            flex-direction: column;
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
        }

        #guildPanel.show {
            display: flex;
            transform: translate(-50%, -50%) scale(1);
        }

        .guild-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 10px 10px 0 0;
            color: #ffd700;
            font-weight: bold;
        }

        .guild-content {
            padding: 16px;
            color: white;
            overflow-y: auto;
            flex: 1;
        }

        .guild-member {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .member-status {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
            background: rgba(46, 213, 115, 0.3);
            color: #2ed573;
        }

        .member-status.offline {
            background: rgba(255, 71, 87, 0.3);
            color: #ff4757;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="hud">
        <!-- Player Panel -->
        <div id="playerPanel">
            <div style="font-weight: bold; margin-bottom: 5px;">
                <span id="playerName">Adventurer</span> - Lv.<span id="playerLevel">1</span>
            </div>
            <div>HP: <span id="playerHP">100</span>/<span id="playerMaxHP">100</span></div>
            <div class="health-bar">
                <div class="health-fill" id="healthFill" style="width: 100%;"></div>
            </div>
            <div>MP: <span id="playerMP">50</span>/<span id="playerMaxMP">50</span></div>
            <div class="mana-bar">
                <div class="mana-fill" id="manaFill" style="width: 100%;"></div>
            </div>
            <div>EXP: <span id="playerEXP">0</span> | Gold: <span id="playerGold">0</span></div>
        </div>

        <!-- Target Panel -->
        <div id="targetPanel">
            <div style="font-weight: bold; margin-bottom: 5px;">
                <span id="targetName">-</span> - Lv.<span id="targetLevel">-</span>
            </div>
            <div>HP: <span id="targetHP">-</span>/<span id="targetMaxHP">-</span></div>
            <div class="health-bar">
                <div class="health-fill" id="targetHealthFill" style="width: 0%;"></div>
            </div>
        </div>

        <!-- Action Bar -->
        <div id="actionBar">
            <div class="skill-slot" data-key="1">1</div>
            <div class="skill-slot" data-key="2">2</div>
            <div class="skill-slot" data-key="3">3</div>
            <div class="skill-slot" data-key="4">4</div>
            <div class="skill-slot" data-key="5">5</div>
            <div class="skill-slot" data-key="6">6</div>
            <div style="margin-left: 10px; color: #aaa; font-size: 11px;">
                Space: Target | Double-Click: Attack
            </div>
        </div>

        <!-- Enhanced Chat Panel -->
        <div id="chatPanel">
            <div class="chat-tabs">
                <button class="chat-tab active" data-tab="general">Generale</button>
                <button class="chat-tab" data-tab="guild">Guild</button>
                <button class="chat-tab" data-tab="system">Sistema</button>
            </div>
            <div id="chatMessages"></div>
            <input type="text" id="chatInput" placeholder="Premi Enter per scrivere...">
        </div>

        <!-- Mini Map -->
        <div id="miniMap">
            <canvas id="miniMapCanvas" width="120" height="120"></canvas>
        </div>
    </div>

    <!-- UI Toggle Buttons -->
    <div class="ui-toggle-btn" id="inventoryBtn" title="Inventario (I)">🎒</div>
    <div class="ui-toggle-btn" id="settingsBtn" title="Impostazioni (Esc)">⚙️</div>
    <div class="ui-toggle-btn" id="guildBtn" title="Guild (G)">👑</div>

    <!-- Mobile-Friendly Inventory Panel -->
    <div id="inventoryPanel">
        <div class="inventory-header">
            <span>Inventario</span>
            <button class="close-btn" onclick="closeInventory()">×</button>
        </div>
        <div class="inventory-grid" id="inventoryGrid">
            <!-- Inventory slots will be generated dynamically -->
        </div>
    </div>

    <!-- Settings Panel -->
    <div id="settingsPanel">
        <div class="inventory-header">
            <span>Impostazioni</span>
            <button class="close-btn" onclick="closeSettings()">×</button>
        </div>
        <div class="settings-content">
            <div class="setting-group">
                <h3>Controlli</h3>
                <div class="setting-item">
                    <span>Vibrazione</span>
                    <div class="setting-toggle active" id="vibrationToggle"></div>
                </div>
                <div class="setting-item">
                    <span>Auto-attacco</span>
                    <div class="setting-toggle active" id="autoAttackToggle"></div>
                </div>
                <div class="setting-item">
                    <span>Dimensione Joystick</span>
                    <div class="setting-slider" id="joystickSizeSlider">
                        <div class="setting-slider-fill">
                            <div class="setting-slider-thumb"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="setting-group">
                <h3>Interfaccia</h3>
                <div class="setting-item">
                    <span>Mostra Minimap</span>
                    <div class="setting-toggle active" id="minimapToggle"></div>
                </div>
                <div class="setting-item">
                    <span>Chat Auto-scroll</span>
                    <div class="setting-toggle active" id="chatScrollToggle"></div>
                </div>
                <div class="setting-item">
                    <span>Dimensione UI</span>
                    <div class="setting-slider" id="uiScaleSlider">
                        <div class="setting-slider-fill">
                            <div class="setting-slider-thumb"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="setting-group">
                <h3>Audio</h3>
                <div class="setting-item">
                    <span>Effetti Sonori</span>
                    <div class="setting-toggle" id="soundToggle"></div>
                </div>
                <div class="setting-item">
                    <span>Volume</span>
                    <div class="setting-slider" id="volumeSlider">
                        <div class="setting-slider-fill">
                            <div class="setting-slider-thumb"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Guild Panel -->
    <div id="guildPanel">
        <div class="guild-header">
            <span>Guild: I Nostalgici</span>
            <button class="close-btn" onclick="closeGuild()">×</button>
        </div>
        <div class="guild-content">
            <div class="setting-group">
                <h3>Membri Online (3/50)</h3>
                <div class="guild-member">
                    <span>Adventurer (Tu)</span>
                    <span class="member-status">Online</span>
                </div>
                <div class="guild-member">
                    <span>GuildMaster</span>
                    <span class="member-status">Online</span>
                </div>
                <div class="guild-member">
                    <span>Warrior123</span>
                    <span class="member-status">Online</span>
                </div>
                <div class="guild-member">
                    <span>Mage_Pro</span>
                    <span class="member-status offline">Offline</span>
                </div>
            </div>
            
            <div class="setting-group">
                <h3>Chat Guild</h3>
                <div style="background: rgba(255, 255, 255, 0.05); padding: 8px; border-radius: 4px; font-size: 11px; max-height: 150px; overflow-y: auto;">
                    <div style="color: #ffd700;">GuildMaster: Benvenuto nella guild!</div>
                    <div style="color: #2ed573;">Warrior123: Qualcuno per dungeon?</div>
                    <div style="color: #4a90e2;">Sistema: Adventurer si è unito alla guild</div>
                </div>
                <input type="text" placeholder="Scrivi in guild..." style="width: 100%; margin-top: 8px; padding: 4px; background: rgba(255,255,255,0.1); border: 1px solid #333; border-radius: 4px; color: white;">
            </div>
        </div>
    </div>

    <!-- Mobile Controls - Landscape Optimized -->
    <div id="mobileControls">
        <div id="joystick">
            <div id="joystickKnob"></div>
        </div>
    </div>

    <!-- Mobile Action Buttons - Right Thumb Zone -->
    <div id="mobileActionButtons">
        <!-- Primary Attack Button (Most Important) -->
        <div class="mobile-btn-primary" id="mobileAttackBtn" title="Attacca/Interagisci">
            ⚔️
        </div>
        <!-- Secondary Select Button -->
        <div class="mobile-btn-secondary" id="mobileTargetBtn" title="Seleziona Target">
            🎯
        </div>
    </div>

    <script>
        class NosTaleGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                
                // Game state
                this.gameState = 'playing';
                this.camera = { x: 0, y: 0 };
                
                // Input handling
                this.keys = {};
                this.lastSpacePress = 0;
                this.lastMouseClick = 0;
                this.selectedTarget = null;
                this.isAutoAttacking = false;
                this.spaceClickCount = 0;
                this.mouseClickCount = 0;
                
                // Mobile support
                this.isMobile = this.detectMobile();
                this.joystickActive = false;
                this.joystickCenter = { x: 0, y: 0 };
                this.moveDirection = { x: 0, y: 0 };
                
                // Initialize game systems
                this.initializePlayer();
                this.initializeEnemies();
                this.initializeInventory();
                this.initializeMiniMap();
                this.initializeSettings();
                this.loadSettings(); // Load saved settings
                this.renderChatMessages();
                this.renderGuildMembers();
                this.setupEventListeners();
                this.setupMobileControls();
                this.setupUIControls();
                this.optimizeUIForDevice();
                this.startGameLoop();
                
                console.log('🎮 NosTale Clone avviato!');
            }

            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.canvas.tabIndex = 1;
            }

            initializePlayer() {
                this.player = {
                    id: 'player',
                    name: 'Adventurer',
                    x: 400,
                    y: 300,
                    level: 1,
                    maxHP: 100,
                    currentHP: 100,
                    maxMP: 50,
                    currentMP: 50,
                    experience: 0,
                    gold: 0,
                    attackMin: 8,
                    attackMax: 15,
                    defense: 3,
                    speed: 120,
                    lastAttack: 0,
                    attackCooldown: 1500,
                    isDead: false,
                    isMoving: false
                };
                this.updatePlayerUI();
            }

            initializeEnemies() {
                this.enemies = [];
                // Spawn alcuni slime
                for (let i = 0; i < 5; i++) {
                    this.spawnEnemy({
                        name: 'Green Slime',
                        level: 1,
                        maxHP: 45,
                        currentHP: 45,
                        attackMin: 3,
                        attackMax: 7,
                        defense: 1,
                        speed: 80,
                        aggroRange: 100,
                        expReward: 15,
                        goldReward: 5
                    });
                }
            }

            initializeInventory() {
                this.inventory = {
                    slots: 25, // 5x5 grid
                    items: []
                };
                
                // Add some starting items
                this.addItemToInventory({
                    id: 'potion_hp_small',
                    name: 'Pozione HP Piccola',
                    icon: '🧪',
                    quantity: 5,
                    type: 'consumable'
                });
                
                this.addItemToInventory({
                    id: 'sword_basic',
                    name: 'Spada Base',
                    icon: '⚔️',
                    quantity: 1,
                    type: 'weapon',
                    attack: 5
                });
                
                this.renderInventory();
            }

            initializeMiniMap() {
                this.miniMapCanvas = document.getElementById('miniMapCanvas');
                this.miniMapCtx = this.miniMapCanvas.getContext('2d');
                this.miniMapScale = 0.1; // Scale factor for minimap
                
                // Minimap click handler
                this.miniMapCanvas.addEventListener('click', (e) => {
                    if (this.isMobile) {
                        const rect = this.miniMapCanvas.getBoundingClientRect();
                        const x = (e.clientX - rect.left) / this.miniMapScale;
                        const y = (e.clientY - rect.top) / this.miniMapScale;
                        
                        // Move player to clicked position (simplified)
                        this.player.x = Math.max(25, Math.min(x, 1000));
                        this.player.y = Math.max(25, Math.min(y, 750));
                        
                        this.addChatMessage('System', '🗺️ Teletrasporto verso la posizione!', 'info');
                    }
                });
            }

            initializeSettings() {
                this.settings = {
                    vibration: true,
                    autoAttack: true,
                    joystickSize: 1.0,
                    showMinimap: true,
                    chatAutoScroll: true,
                    uiScale: 1.0,
                    soundEffects: false,
                    volume: 0.5
                };
                
                this.currentChatTab = 'general';
                this.chatMessages = {
                    general: [],
                    guild: [],
                    party: [],
                    trade: [],
                    system: []
                };
                
                this.guildMembers = [
                    { name: 'GuildMaster', level: 99, online: true, role: 'Leader' },
                    { name: 'Warrior123', level: 45, online: true, role: 'Officer' },
                    { name: 'Healer_Pro', level: 38, online: false, role: 'Member' },
                    { name: 'MageX', level: 52, online: true, role: 'Member' }
                ];
            }

            // Chat management functions
            switchChatTab(tabName) {
                this.currentChatTab = tabName;
                
                // Update tab appearance
                document.querySelectorAll('.chat-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                
                const activeTab = document.querySelector(`.chat-tab[onclick*="${tabName}"]`);
                if (activeTab) activeTab.classList.add('active');
                
                // Render messages for this tab
                this.renderChatMessages();
            }

            renderChatMessages() {
                const chatMessages = document.getElementById('chatMessages');
                if (!chatMessages) return;
                
                chatMessages.innerHTML = '';
                
                const messages = this.chatMessages[this.currentChatTab] || [];
                
                messages.forEach(msg => {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'chat-message';
                    messageDiv.style.color = msg.color;
                    messageDiv.innerHTML = `<strong>${msg.sender}:</strong> ${msg.text}`;
                    chatMessages.appendChild(messageDiv);
                });
                
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }

            sendChatMessage() {
                const input = document.getElementById('chatInput');
                if (!input) return;
                
                const message = input.value.trim();
                if (!message) return;
                
                // Determine message type based on current tab
                let type = '';
                switch (this.currentChatTab) {
                    case 'guild':
                        type = 'Guild';
                        break;
                    case 'party':
                        type = 'Party';
                        break;
                    case 'trade':
                        type = 'Trade';
                        break;
                    default:
                        type = 'General';
                }
                
                this.addChatMessage('You', message, 'info', this.currentChatTab);
                input.value = '';
                
                // Auto-response simulation for demonstration
                setTimeout(() => {
                    const responses = {
                        general: ['Hello there!', 'Nice weather today!', 'Anyone up for a quest?'],
                        guild: ['Guild meeting tonight!', 'Great job on that raid!', 'Welcome new members!'],
                        party: ['Ready for dungeon?', 'Need healer for party!', 'Nice combo attack!'],
                        trade: ['Selling rare items!', 'Looking to buy potions!', 'Great prices here!']
                    };
                    
                    const tabResponses = responses[this.currentChatTab] || responses.general;
                    const randomResponse = tabResponses[Math.floor(Math.random() * tabResponses.length)];
                    this.addChatMessage('Player' + Math.floor(Math.random() * 100), randomResponse, '', this.currentChatTab);
                }, 1000 + Math.random() * 2000);
            }

            // Guild management functions
            addGuildMember() {
                const memberName = prompt('Enter guild member name:');
                if (!memberName) return;
                
                const member = {
                    name: memberName,
                    level: Math.floor(Math.random() * 50) + 1,
                    online: Math.random() > 0.3,
                    role: 'Member'
                };
                
                this.guildMembers.push(member);
                this.renderGuildMembers();
            }

            renderGuildMembers() {
                const membersList = document.getElementById('guildMembersList');
                if (!membersList) return;
                
                membersList.innerHTML = '';
                
                this.guildMembers.forEach((member, index) => {
                    const memberDiv = document.createElement('div');
                    memberDiv.className = `guild-member ${member.online ? 'online' : 'offline'}`;
                    memberDiv.innerHTML = `
                        <span class="member-name">${member.name}</span>
                        <span class="member-level">Lv.${member.level}</span>
                        <span class="member-role">${member.role}</span>
                        <button onclick="game.removeGuildMember(${index})" class="remove-btn">×</button>
                    `;
                    membersList.appendChild(memberDiv);
                });
            }

            removeGuildMember(index) {
                if (confirm('Remove this member from guild?')) {
                    this.guildMembers.splice(index, 1);
                    this.renderGuildMembers();
                }
            }

            // Settings management functions
            updateSettingsUI() {
                const settingsMap = {
                    'vibrationToggle': 'vibration',
                    'autoAttackToggle': 'autoAttack',
                    'showMinimapToggle': 'showMinimap',
                    'chatAutoScrollToggle': 'chatAutoScroll',
                    'soundEffectsToggle': 'soundEffects',
                    'joystickSizeSlider': 'joystickSize',
                    'uiScaleSlider': 'uiScale',
                    'volumeSlider': 'volume'
                };
                
                for (const [elementId, settingKey] of Object.entries(settingsMap)) {
                    const element = document.getElementById(elementId);
                    if (element) {
                        if (element.type === 'checkbox') {
                            element.checked = this.settings[settingKey];
                        } else if (element.type === 'range') {
                            element.value = this.settings[settingKey];
                            // Update display value
                            const valueDisplay = document.getElementById(elementId + 'Value');
                            if (valueDisplay) {
                                if (settingKey === 'volume') {
                                    valueDisplay.textContent = Math.round(this.settings[settingKey] * 100) + '%';
                                } else {
                                    valueDisplay.textContent = this.settings[settingKey];
                                }
                            }
                        }
                    }
                }
            }

            updateSetting(elementId, value) {
                const settingsMap = {
                    'vibrationToggle': 'vibration',
                    'autoAttackToggle': 'autoAttack',
                    'showMinimapToggle': 'showMinimap',
                    'chatAutoScrollToggle': 'chatAutoScroll',
                    'soundEffectsToggle': 'soundEffects',
                    'joystickSizeSlider': 'joystickSize',
                    'uiScaleSlider': 'uiScale',
                    'volumeSlider': 'volume'
                };
                
                const settingKey = settingsMap[elementId];
                if (settingKey) {
                    this.settings[settingKey] = value;
                    this.saveSettings();
                    
                    // Update display value for sliders
                    if (elementId.includes('Slider')) {
                        const valueDisplay = document.getElementById(elementId + 'Value');
                        if (valueDisplay) {
                            if (settingKey === 'volume') {
                                valueDisplay.textContent = Math.round(value * 100) + '%';
                            } else {
                                valueDisplay.textContent = value;
                            }
                        }
                    }
                }
            }

            saveSettings() {
                localStorage.setItem('gameSettings', JSON.stringify(this.settings));
            }

            loadSettings() {
                const saved = localStorage.getItem('gameSettings');
                if (saved) {
                    this.settings = { ...this.settings, ...JSON.parse(saved) };
                    this.updateSettingsUI();
                }
            }

            spawnEnemy(template) {
                const enemy = {
                    ...template,
                    id: 'enemy_' + Date.now() + Math.random(),
                    x: Math.random() * 800 + 100,
                    y: Math.random() * 600 + 100,
                    target: null,
                    lastAttack: 0,
                    attackCooldown: 2000,
                    isDead: false,
                    lastAction: 0
                };
                this.enemies.push(enemy);
            }

            setupEventListeners() {
                // Keyboard
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));
                document.addEventListener('keyup', (e) => this.handleKeyUp(e));
                
                // Mouse/Touch Events
                this.canvas.addEventListener('click', (e) => this.handleMouseClick(e));
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
                
                // Touch movement
                this.canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault(); // Prevent scrolling
                }, { passive: false });
                
                // Chat
                const chatInput = document.getElementById('chatInput');
                if (chatInput) {
                    chatInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            this.sendChatMessage();
                            chatInput.blur();
                        }
                    });
                }
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.setupCanvas();
                    this.optimizeUIForDevice();
                });
                
                // Prevent zoom on mobile
                document.addEventListener('gesturestart', (e) => e.preventDefault());
                document.addEventListener('gesturechange', (e) => e.preventDefault());
            }

            detectMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }

            setupMobileControls() {
                if (!this.isMobile) return;

                const joystick = document.getElementById('joystick');
                const joystickKnob = document.getElementById('joystickKnob');
                
                // Joystick touch events
                joystick.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.joystickActive = true;
                    const rect = joystick.getBoundingClientRect();
                    this.joystickCenter = {
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height / 2
                    };
                });

                joystick.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.joystickActive) return;
                    
                    const touch = e.touches[0];
                    const deltaX = touch.clientX - this.joystickCenter.x;
                    const deltaY = touch.clientY - this.joystickCenter.y;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    
                    const maxDistance = 40;
                    const clampedDistance = Math.min(distance, maxDistance);
                    
                    if (distance > 5) {
                        const angle = Math.atan2(deltaY, deltaX);
                        const knobX = Math.cos(angle) * clampedDistance;
                        const knobY = Math.sin(angle) * clampedDistance;
                        
                        joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
                        
                        this.moveDirection = {
                            x: knobX / maxDistance,
                            y: knobY / maxDistance
                        };
                    } else {
                        this.moveDirection = { x: 0, y: 0 };
                        joystickKnob.style.transform = 'translate(-50%, -50%)';
                    }
                });

                joystick.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.joystickActive = false;
                    this.moveDirection = { x: 0, y: 0 };
                    joystickKnob.style.transform = 'translate(-50%, -50%)';
                });

                // Mobile action buttons - Optimized for landscape gaming
                const targetBtn = document.getElementById('mobileTargetBtn');
                const attackBtn = document.getElementById('mobileAttackBtn');

                // Target button - Single tap to select nearest enemy
                targetBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.selectNearestEnemy();
                    // Visual feedback
                    targetBtn.style.transform = 'scale(0.9)';
                });

                targetBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    targetBtn.style.transform = 'scale(1)';
                });

                // Attack button - Enhanced with double-tap detection
                let attackTapCount = 0;
                let attackTapTimer = null;

                attackBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    attackTapCount++;
                    
                    // Visual feedback
                    attackBtn.style.transform = 'scale(0.9)';
                    
                    if (attackTapCount === 1) {
                        attackTapTimer = setTimeout(() => {
                            // Single tap - select target if none selected
                            if (!this.selectedTarget) {
                                this.selectNearestEnemy();
                            }
                            attackTapCount = 0;
                        }, 300);
                    } else if (attackTapCount === 2) {
                        // Double tap - attack target
                        clearTimeout(attackTapTimer);
                        if (this.selectedTarget) {
                            this.isAutoAttacking = true;
                            this.addChatMessage('System', `⚔️ Auto-attacco su ${this.selectedTarget.name}!`, 'info');
                        } else {
                            this.selectNearestEnemy();
                            if (this.selectedTarget) {
                                this.isAutoAttacking = true;
                                this.addChatMessage('System', `⚔️ Attacco ${this.selectedTarget.name}!`, 'info');
                            }
                        }
                        attackTapCount = 0;
                    }
                });

                attackBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    attackBtn.style.transform = 'scale(1)';
                });
            }

            setupUIControls() {
                // Inventory button
                document.getElementById('inventoryBtn').addEventListener('click', () => {
                    this.toggleInventory();
                });
                
                // Settings button
                document.getElementById('settingsBtn').addEventListener('click', () => {
                    this.toggleSettings();
                });
                
                // Guild button
                document.getElementById('guildBtn').addEventListener('click', () => {
                    this.toggleGuild();
                });
                
                // Chat tabs
                document.querySelectorAll('.chat-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        this.switchChatTab(e.target.dataset.tab);
                    });
                });
                
                // Settings toggles
                this.setupSettingsControls();
            }

            setupSettingsControls() {
                // Vibration toggle
                document.getElementById('vibrationToggle').addEventListener('click', (e) => {
                    this.settings.vibration = !this.settings.vibration;
                    e.target.classList.toggle('active', this.settings.vibration);
                });
                
                // Auto-attack toggle
                document.getElementById('autoAttackToggle').addEventListener('click', (e) => {
                    this.settings.autoAttack = !this.settings.autoAttack;
                    e.target.classList.toggle('active', this.settings.autoAttack);
                });
                
                // Minimap toggle
                document.getElementById('minimapToggle').addEventListener('click', (e) => {
                    this.settings.showMinimap = !this.settings.showMinimap;
                    e.target.classList.toggle('active', this.settings.showMinimap);
                    document.getElementById('miniMap').style.display = this.settings.showMinimap ? 'block' : 'none';
                });
                
                // Chat auto-scroll toggle
                document.getElementById('chatScrollToggle').addEventListener('click', (e) => {
                    this.settings.chatAutoScroll = !this.settings.chatAutoScroll;
                    e.target.classList.toggle('active', this.settings.chatAutoScroll);
                });
                
                // Sound toggle
                document.getElementById('soundToggle').addEventListener('click', (e) => {
                    this.settings.soundEffects = !this.settings.soundEffects;
                    e.target.classList.toggle('active', this.settings.soundEffects);
                });
            }

            // Inventory Management
            addItemToInventory(item) {
                const existingItem = this.inventory.items.find(i => i.id === item.id);
                if (existingItem) {
                    existingItem.quantity += item.quantity;
                } else {
                    this.inventory.items.push(item);
                }
                this.renderInventory();
            }

            renderInventory() {
                const grid = document.getElementById('inventoryGrid');
                grid.innerHTML = '';
                
                for (let i = 0; i < this.inventory.slots; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'inventory-slot';
                    slot.dataset.slot = i;
                    
                    const item = this.inventory.items[i];
                    if (item) {
                        slot.classList.add('has-item');
                        slot.innerHTML = `
                            <div class="item-icon">${item.icon}</div>
                            ${item.quantity > 1 ? `<div class="item-quantity">${item.quantity}</div>` : ''}
                        `;
                        slot.title = item.name;
                    }
                    
                    slot.addEventListener('click', () => {
                        if (item) {
                            this.useItem(item);
                        }
                    });
                    
                    grid.appendChild(slot);
                }
            }

            useItem(item) {
                if (item.type === 'consumable' && item.id === 'potion_hp_small') {
                    if (this.player.currentHP < this.player.maxHP) {
                        this.player.currentHP = Math.min(this.player.maxHP, this.player.currentHP + 25);
                        item.quantity--;
                        
                        if (item.quantity <= 0) {
                            const index = this.inventory.items.indexOf(item);
                            this.inventory.items.splice(index, 1);
                        }
                        
                        this.updatePlayerUI();
                        this.renderInventory();
                        this.addChatMessage('System', '🧪 Hai usato una Pozione HP Piccola!', 'success');
                        
                        if (this.settings.vibration && navigator.vibrate) {
                            navigator.vibrate(100);
                        }
                    } else {
                        this.addChatMessage('System', 'HP già al massimo!', 'warning');
                    }
                }
            }

            // UI Panel Management
            toggleInventory() {
                const panel = document.getElementById('inventoryPanel');
                const isOpen = panel.classList.contains('show');
                
                this.closeAllPanels();
                
                if (!isOpen) {
                    panel.classList.add('show');
                    this.renderInventory();
                }
            }

            toggleSettings() {
                const panel = document.getElementById('settingsPanel');
                const isOpen = panel.classList.contains('show');
                
                this.closeAllPanels();
                
                if (!isOpen) {
                    panel.classList.add('show');
                }
            }

            toggleGuild() {
                const panel = document.getElementById('guildPanel');
                const isOpen = panel.classList.contains('show');
                
                this.closeAllPanels();
                
                if (!isOpen) {
                    panel.classList.add('show');
                }
            }

            closeAllPanels() {
                document.getElementById('inventoryPanel').classList.remove('show');
                document.getElementById('settingsPanel').classList.remove('show');
                document.getElementById('guildPanel').classList.remove('show');
            }

            switchChatTab(tabName) {
                this.currentChatTab = tabName;
                
                // Update tab appearance
                document.querySelectorAll('.chat-tab').forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabName);
                });
                
                // Update chat messages
                this.renderChatMessages();
            }

            renderChatMessages() {
                const chatMessages = document.getElementById('chatMessages');
                chatMessages.innerHTML = '';
                
                const messages = this.chatMessages[this.currentChatTab] || [];
                messages.forEach(msg => {
                    const messageDiv = document.createElement('div');
                    messageDiv.style.color = msg.color;
                    messageDiv.innerHTML = `<strong>${msg.sender}:</strong> ${msg.text}`;
                    chatMessages.appendChild(messageDiv);
                });
                
                if (this.settings.chatAutoScroll) {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }
            }

            handleKeyDown(e) {
                this.keys[e.key.toLowerCase()] = true;
                
                // Dead player can only respawn
                if (this.player.isDead) {
                    if (e.key === ' ' || e.key === 'Enter' || e.key.toLowerCase() === 'r') {
                        this.respawnPlayer();
                    }
                    return;
                }
                
                // Skill selection (1-6 keys)
                if (['1', '2', '3', '4', '5', '6'].includes(e.key)) {
                    this.selectSkill(parseInt(e.key) - 1);
                }
                
                // Spacebar for targeting
                if (e.key === ' ') {
                    e.preventDefault();
                    this.handleSpacebarPress();
                }
                
                // Tab for next enemy
                if (e.key === 'Tab') {
                    e.preventDefault();
                    this.selectNextEnemy();
                }
                
                // Escape to deselect
                if (e.key === 'Escape') {
                    this.selectedTarget = null;
                    this.isAutoAttacking = false;
                    this.updateTargetUI();
                }
                
                // Enter for chat
                if (e.key === 'Enter') {
                    document.getElementById('chatInput').focus();
                }
                
                // Inventory (I key)
                if (e.key.toLowerCase() === 'i') {
                    this.toggleInventory();
                }
                
                // Guild (G key)
                if (e.key.toLowerCase() === 'g') {
                    this.toggleGuild();
                }
                
                // Settings (Esc key)
                if (e.key === 'Escape') {
                    if (document.getElementById('inventoryPanel').classList.contains('show') ||
                        document.getElementById('settingsPanel').classList.contains('show') ||
                        document.getElementById('guildPanel').classList.contains('show')) {
                        this.closeAllPanels();
                    } else {
                        this.toggleSettings();
                    }
                }
            }

            handleKeyUp(e) {
                this.keys[e.key.toLowerCase()] = false;
            }

            handleMouseClick(e) {
                if (this.player.isDead) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left + this.camera.x;
                const mouseY = e.clientY - rect.top + this.camera.y;
                
                this.handleTargetingInput(mouseX, mouseY, 'mouse');
            }

            handleTouchStart(e) {
                e.preventDefault();
                if (this.player.isDead) return;
                
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left + this.camera.x;
                const touchY = touch.clientY - rect.top + this.camera.y;
                
                this.touchStartTime = Date.now();
                this.touchStartX = touchX;
                this.touchStartY = touchY;
            }

            handleTouchEnd(e) {
                e.preventDefault();
                if (this.player.isDead) return;
                
                const touchEndTime = Date.now();
                const touchDuration = touchEndTime - this.touchStartTime;
                
                // Se è un tap (non un trascinamento lungo)
                if (touchDuration < 500) {
                    this.handleTargetingInput(this.touchStartX, this.touchStartY, 'touch');
                }
            }

            handleTargetingInput(x, y, inputType) {
                const now = Date.now();
                const clickedEnemy = this.getEnemyAtPosition(x, y);
                
                if (clickedEnemy && !clickedEnemy.isDead) {
                    // Se è lo stesso nemico selezionato
                    if (this.selectedTarget === clickedEnemy) {
                        if (inputType === 'mouse') {
                            this.mouseClickCount++;
                            setTimeout(() => { this.mouseClickCount = 0; }, 500);
                            
                            if (this.mouseClickCount >= 2) {
                                // Doppio click mouse - attacca e insegui
                                this.isAutoAttacking = true;
                                this.addChatMessage('System', `🎯 Auto-attacco su ${clickedEnemy.name}!`, 'info');
                                this.mouseClickCount = 0;
                            }
                        } else if (inputType === 'touch') {
                            // Su touch, doppio tap per attaccare
                            if (now - this.lastMouseClick < 500) {
                                this.isAutoAttacking = true;
                                this.addChatMessage('System', `🎯 Auto-attacco su ${clickedEnemy.name}!`, 'info');
                            }
                        }
                    } else {
                        // Nuovo nemico selezionato - singolo click/tap
                        this.selectedTarget = clickedEnemy;
                        this.isAutoAttacking = false;
                        this.mouseClickCount = 1;
                        this.addChatMessage('System', `👁️ ${clickedEnemy.name} selezionato`, 'warning');
                    }
                    
                    this.lastMouseClick = now;
                    this.updateTargetUI();
                } else {
                    // Click su area vuota - deseleziona
                    this.selectedTarget = null;
                    this.isAutoAttacking = false;
                    this.mouseClickCount = 0;
                    this.updateTargetUI();
                }
            }

            handleSpacebarPress() {
                const now = Date.now();
                
                // Incrementa counter e resetta dopo 500ms
                this.spaceClickCount++;
                setTimeout(() => { this.spaceClickCount = 0; }, 500);
                
                if (this.spaceClickCount === 1) {
                    // Primo click spacebar - seleziona nemico più vicino
                    this.selectNearestEnemy();
                } else if (this.spaceClickCount >= 2 && this.selectedTarget) {
                    // Doppio click spacebar - attacca e insegui nemico selezionato
                    this.isAutoAttacking = true;
                    this.addChatMessage('System', `⚔️ Auto-attacco su ${this.selectedTarget.name}!`, 'info');
                    this.spaceClickCount = 0; // Reset counter
                }
                
                this.lastSpacePress = now;
            }

            selectSkill(index) {
                // Remove previous selection
                document.querySelectorAll('.skill-slot').forEach(slot => {
                    slot.classList.remove('selected');
                });
                
                // Select new skill
                const slots = document.querySelectorAll('.skill-slot');
                if (slots[index]) {
                    slots[index].classList.add('selected');
                    this.addChatMessage('System', `Skill ${index + 1} selezionata`, 'info');
                }
            }

            selectNearestEnemy() {
                const aliveEnemies = this.enemies.filter(e => !e.isDead);
                if (aliveEnemies.length === 0) return;
                
                let nearest = null;
                let nearestDistance = Infinity;
                
                aliveEnemies.forEach(enemy => {
                    const distance = this.getDistance(this.player, enemy);
                    if (distance < nearestDistance) {
                        nearestDistance = distance;
                        nearest = enemy;
                    }
                });
                
                this.selectedTarget = nearest;
                this.updateTargetUI();
            }

            selectNextEnemy() {
                const aliveEnemies = this.enemies.filter(e => !e.isDead);
                if (aliveEnemies.length === 0) return;
                
                let currentIndex = this.selectedTarget ? aliveEnemies.indexOf(this.selectedTarget) : -1;
                const nextIndex = (currentIndex + 1) % aliveEnemies.length;
                
                this.selectedTarget = aliveEnemies[nextIndex];
                this.updateTargetUI();
            }

            getEnemyAtPosition(x, y) {
                for (const enemy of this.enemies) {
                    if (enemy.isDead) continue;
                    const distance = Math.sqrt((x - enemy.x) ** 2 + (y - enemy.y) ** 2);
                    if (distance < 25) return enemy;
                }
                return null;
            }

            // Game update loop
            update(deltaTime) {
                if (this.gameState !== 'playing') return;
                
                this.updatePlayer(deltaTime);
                this.updateEnemies(deltaTime);
                this.updateAutoAttack(deltaTime);
                this.updateCamera();
            }

            updatePlayer(deltaTime) {
                if (this.player.isDead) return;
                
                // Movement - keyboard controls
                let moveX = 0, moveY = 0;
                if (this.keys['w'] || this.keys['arrowup']) moveY = -1;
                if (this.keys['s'] || this.keys['arrowdown']) moveY = 1;
                if (this.keys['a'] || this.keys['arrowleft']) moveX = -1;
                if (this.keys['d'] || this.keys['arrowright']) moveX = 1;
                
                // Mobile joystick controls (override keyboard if active)
                if (this.isMobile && (this.moveDirection.x !== 0 || this.moveDirection.y !== 0)) {
                    moveX = this.moveDirection.x;
                    moveY = this.moveDirection.y;
                }
                
                // Normalize diagonal movement
                if (moveX !== 0 && moveY !== 0) {
                    moveX *= 0.707;
                    moveY *= 0.707;
                }
                
                // Apply movement
                if (moveX !== 0 || moveY !== 0) {
                    this.player.x += moveX * this.player.speed * (deltaTime / 1000);
                    this.player.y += moveY * this.player.speed * (deltaTime / 1000);
                    this.player.isMoving = true;
                    
                    // Stop auto-attacking when moving
                    if (this.isAutoAttacking) {
                        this.isAutoAttacking = false;
                    }
                } else {
                    this.player.isMoving = false;
                }
                
                // Keep player in bounds
                this.player.x = Math.max(25, Math.min(this.player.x, 1000));
                this.player.y = Math.max(25, Math.min(this.player.y, 750));
                
                // Check for death
                if (this.player.currentHP <= 0 && !this.player.isDead) {
                    this.killPlayer();
                }
            }

            updateEnemies(deltaTime) {
                this.enemies.forEach(enemy => {
                    if (enemy.isDead) return;
                    
                    // Simple AI
                    const distanceToPlayer = this.getDistance(enemy, this.player);
                    
                    // Aggro check
                    if (!enemy.target && distanceToPlayer <= enemy.aggroRange && !this.player.isDead) {
                        enemy.target = this.player;
                    }
                    
                    // Lose aggro if too far
                    if (enemy.target && distanceToPlayer > enemy.aggroRange * 2) {
                        enemy.target = null;
                    }
                    
                    // Attack or move
                    if (enemy.target) {
                        if (distanceToPlayer <= 35) {
                            // Attack
                            const now = Date.now();
                            if (now - enemy.lastAttack > enemy.attackCooldown) {
                                this.enemyAttackPlayer(enemy);
                                enemy.lastAttack = now;
                            }
                        } else if (distanceToPlayer <= enemy.aggroRange * 1.5) {
                            // Move toward player
                            this.moveEnemyToward(enemy, this.player, deltaTime);
                        }
                    }
                    
                    // Check for death
                    if (enemy.currentHP <= 0) {
                        this.killEnemy(enemy);
                    }
                });
            }

            updateAutoAttack(deltaTime) {
                if (!this.isAutoAttacking || !this.selectedTarget || this.selectedTarget.isDead || this.player.isDead) {
                    this.isAutoAttacking = false;
                    return;
                }
                
                const distance = this.getDistance(this.player, this.selectedTarget);
                
                // Move closer if needed
                if (distance > 45) {
                    this.movePlayerToward(this.selectedTarget, deltaTime);
                } else {
                    // Attack
                    const now = Date.now();
                    if (now - this.player.lastAttack > this.player.attackCooldown) {
                        this.playerAttackEnemy(this.selectedTarget);
                        this.player.lastAttack = now;
                    }
                }
            }

            moveEnemyToward(enemy, target, deltaTime) {
                const dx = target.x - enemy.x;
                const dy = target.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 30) {
                    const speed = enemy.speed;
                    enemy.x += (dx / distance) * speed * (deltaTime / 1000);
                    enemy.y += (dy / distance) * speed * (deltaTime / 1000);
                }
            }

            movePlayerToward(target, deltaTime) {
                const dx = target.x - this.player.x;
                const dy = target.y - this.player.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 45) {
                    const speed = this.player.speed;
                    this.player.x += (dx / distance) * speed * (deltaTime / 1000);
                    this.player.y += (dy / distance) * speed * (deltaTime / 1000);
                }
            }

            playerAttackEnemy(enemy) {
                const damage = Math.floor(Math.random() * (this.player.attackMax - this.player.attackMin + 1)) + this.player.attackMin;
                const finalDamage = Math.max(1, damage - enemy.defense);
                
                enemy.currentHP -= finalDamage;
                this.createFloatingText(enemy.x, enemy.y - 20, `-${finalDamage}`, '#ff4444');
                
                console.log(`⚔️ Player attacca ${enemy.name} per ${finalDamage} danni`);
            }

            enemyAttackPlayer(enemy) {
                const damage = Math.floor(Math.random() * (enemy.attackMax - enemy.attackMin + 1)) + enemy.attackMin;
                const finalDamage = Math.max(1, damage - this.player.defense);
                
                this.player.currentHP -= finalDamage;
                this.createFloatingText(this.player.x, this.player.y - 20, `-${finalDamage}`, '#ff6666');
                this.updatePlayerUI();
                
                console.log(`💥 ${enemy.name} attacca il player per ${finalDamage} danni`);
            }

            killPlayer() {
                this.player.isDead = true;
                this.player.currentHP = 0;
                this.selectedTarget = null;
                this.isAutoAttacking = false;
                this.gameState = 'gameover';
                
                this.showDeathScreen();
                this.addChatMessage('System', 'Sei morto! Premi SPACE per respawnare.', 'error');
            }

            killEnemy(enemy) {
                enemy.isDead = true;
                
                // Give rewards
                this.player.experience += enemy.expReward;
                this.player.gold += enemy.goldReward;
                
                this.addChatMessage('System', `${enemy.name} sconfitto! +${enemy.expReward} EXP, +${enemy.goldReward} Gold`, 'success');
                
                // Clear target if this was it
                if (this.selectedTarget === enemy) {
                    this.selectedTarget = null;
                    this.isAutoAttacking = false;
                    this.updateTargetUI();
                }
                
                this.updatePlayerUI();
                
                // Respawn enemy after some time
                setTimeout(() => {
                    const index = this.enemies.indexOf(enemy);
                    if (index > -1) {
                        this.enemies.splice(index, 1);
                        this.spawnEnemy({
                            name: 'Green Slime',
                            level: 1,
                            maxHP: 45,
                            currentHP: 45,
                            attackMin: 3,
                            attackMax: 7,
                            defense: 1,
                            speed: 80,
                            aggroRange: 100,
                            expReward: 15,
                            goldReward: 5
                        });
                    }
                }, 5000);
            }

            respawnPlayer() {
                this.player.isDead = false;
                this.player.currentHP = Math.floor(this.player.maxHP * 0.5);
                this.player.currentMP = this.player.maxMP;
                this.player.x = 400;
                this.player.y = 300;
                this.gameState = 'playing';
                
                // Remove death screen
                const deathScreen = document.getElementById('deathScreen');
                if (deathScreen) {
                    deathScreen.remove();
                }
                
                this.updatePlayerUI();
                this.addChatMessage('System', 'Respawn completato!', 'info');
            }

            updateCamera() {
                // Simple camera follow
                this.camera.x = this.player.x - this.canvas.width / 2;
                this.camera.y = this.player.y - this.canvas.height / 2;
                
                // Keep camera in bounds
                this.camera.x = Math.max(0, Math.min(this.camera.x, 1000 - this.canvas.width));
                this.camera.y = Math.max(0, Math.min(this.camera.y, 750 - this.canvas.height));
            }

            // Rendering
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Background
                this.ctx.fillStyle = '#2d4a2b';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.renderGrid();
                this.renderEnemies();
                this.renderPlayer();
                this.renderEffects();
                
                // Update minimap if enabled
                if (this.settings.showMinimap) {
                    this.renderMiniMap();
                }
            }

            renderMiniMap() {
                if (!this.miniMapCtx) return;
                
                const ctx = this.miniMapCtx;
                const width = this.miniMapCanvas.width;
                const height = this.miniMapCanvas.height;
                
                // Clear minimap
                ctx.fillStyle = '#1a3328';
                ctx.fillRect(0, 0, width, height);
                
                // Draw world bounds
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, 0, 100, 75);
                
                // Draw player position
                const playerX = (this.player.x / 1000) * 100;
                const playerY = (this.player.y / 750) * 75;
                
                ctx.fillStyle = '#4a90e2';
                ctx.fillRect(playerX - 1, playerY - 1, 2, 2);
                
                // Draw enemies
                this.enemies.forEach(enemy => {
                    if (!enemy.isDead) {
                        const enemyX = (enemy.x / 1000) * 100;
                        const enemyY = (enemy.y / 750) * 75;
                        
                        ctx.fillStyle = enemy === this.selectedTarget ? '#ffff00' : '#ff4757';
                        ctx.fillRect(enemyX - 0.5, enemyY - 0.5, 1, 1);
                    }
                });
                
                // Draw camera view rectangle
                const camX = (this.camera.x / 1000) * 100;
                const camY = (this.camera.y / 750) * 75;
                const camW = (this.canvas.width / 1000) * 100;
                const camH = (this.canvas.height / 750) * 75;
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.strokeRect(camX, camY, camW, camH);
            }

            renderGrid() {
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                const startX = -this.camera.x % gridSize;
                const startY = -this.camera.y % gridSize;
                
                for (let x = startX; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = startY; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            renderPlayer() {
                const screenX = this.player.x - this.camera.x;
                const screenY = this.player.y - this.camera.y;
                
                // Player body
                this.ctx.fillStyle = this.player.isDead ? '#666' : '#4a90e2';
                this.ctx.fillRect(screenX - 15, screenY - 15, 30, 30);
                
                // Player name
                this.ctx.fillStyle = 'white';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(this.player.name, screenX, screenY - 20);
                
                // HP bar
                this.renderHealthBar(screenX, screenY + 20, this.player.currentHP, this.player.maxHP);
            }

            renderEnemies() {
                this.enemies.forEach(enemy => {
                    if (enemy.isDead) return;
                    
                    const screenX = enemy.x - this.camera.x;
                    const screenY = enemy.y - this.camera.y;
                    
                    // Skip if off-screen
                    if (screenX < -50 || screenX > this.canvas.width + 50 || 
                        screenY < -50 || screenY > this.canvas.height + 50) return;
                    
                    // Enemy body
                    this.ctx.fillStyle = enemy === this.selectedTarget ? '#ffff00' : '#2ed573';
                    this.ctx.fillRect(screenX - 12, screenY - 12, 24, 24);
                    
                    // Enemy name
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = '10px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(`${enemy.name} Lv.${enemy.level}`, screenX, screenY - 18);
                    
                    // HP bar
                    this.renderHealthBar(screenX, screenY + 18, enemy.currentHP, enemy.maxHP);
                    
                    // Target indicator
                    if (enemy === this.selectedTarget) {
                        this.ctx.strokeStyle = '#ffff00';
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeRect(screenX - 15, screenY - 15, 30, 30);
                    }
                });
            }

            renderHealthBar(x, y, currentHP, maxHP) {
                const width = 30;
                const height = 4;
                
                // Background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                this.ctx.fillRect(x - width/2, y, width, height);
                
                // Health fill
                const hpPercent = currentHP / maxHP;
                this.ctx.fillStyle = hpPercent > 0.6 ? '#2ed573' : hpPercent > 0.3 ? '#ffa726' : '#ff4757';
                this.ctx.fillRect(x - width/2, y, width * hpPercent, height);
            }

            renderEffects() {
                // Render any floating text or effects here
                // Implementation would go here for floating damage numbers, etc.
            }

            // UI Updates
            updatePlayerUI() {
                document.getElementById('playerName').textContent = this.player.name;
                document.getElementById('playerLevel').textContent = this.player.level;
                document.getElementById('playerHP').textContent = this.player.currentHP;
                document.getElementById('playerMaxHP').textContent = this.player.maxHP;
                document.getElementById('playerMP').textContent = this.player.currentMP;
                document.getElementById('playerMaxMP').textContent = this.player.maxMP;
                document.getElementById('playerEXP').textContent = this.player.experience;
                document.getElementById('playerGold').textContent = this.player.gold;
                
                const hpPercent = (this.player.currentHP / this.player.maxHP) * 100;
                const mpPercent = (this.player.currentMP / this.player.maxMP) * 100;
                
                document.getElementById('healthFill').style.width = hpPercent + '%';
                document.getElementById('manaFill').style.width = mpPercent + '%';
            }

            updateTargetUI() {
                const targetPanel = document.getElementById('targetPanel');
                
                if (this.selectedTarget && !this.selectedTarget.isDead) {
                    targetPanel.style.display = 'block';
                    document.getElementById('targetName').textContent = this.selectedTarget.name;
                    document.getElementById('targetLevel').textContent = this.selectedTarget.level;
                    document.getElementById('targetHP').textContent = this.selectedTarget.currentHP;
                    document.getElementById('targetMaxHP').textContent = this.selectedTarget.maxHP;
                    
                    const hpPercent = (this.selectedTarget.currentHP / this.selectedTarget.maxHP) * 100;
                    document.getElementById('targetHealthFill').style.width = hpPercent + '%';
                } else {
                    targetPanel.style.display = 'none';
                }
            }

            showDeathScreen() {
                const deathScreen = document.createElement('div');
                deathScreen.id = 'deathScreen';
                deathScreen.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    z-index: 1000;
                    color: white;
                    font-family: Arial, sans-serif;
                `;
                
                deathScreen.innerHTML = `
                    <h1 style="color: #ff4757; font-size: 48px; margin-bottom: 20px;">GAME OVER</h1>
                    <p style="font-size: 18px; margin-bottom: 20px;">
                        Livello: ${this.player.level} | EXP: ${this.player.experience} | Gold: ${this.player.gold}
                    </p>
                    <p style="font-size: 16px; color: #ffa726;">
                        Premi SPACE, ENTER o R per respawnare
                    </p>
                `;
                
                document.body.appendChild(deathScreen);
            }

            addChatMessage(sender, message, type = '', tab = null) {
                const targetTab = tab || this.currentChatTab;
                
                let color = 'white';
                if (type === 'error') color = '#ff4757';
                else if (type === 'success') color = '#2ed573';
                else if (type === 'info') color = '#4a90e2';
                else if (type === 'warning') color = '#ffa726';
                
                // Add to message history
                const messageObj = {
                    sender,
                    text: message,
                    color,
                    timestamp: Date.now()
                };
                
                if (!this.chatMessages[targetTab]) {
                    this.chatMessages[targetTab] = [];
                }
                
                this.chatMessages[targetTab].push(messageObj);
                
                // Keep only last 50 messages per tab
                if (this.chatMessages[targetTab].length > 50) {
                    this.chatMessages[targetTab].shift();
                }
                
                // Update display if this is the current tab
                if (targetTab === this.currentChatTab) {
                    this.renderChatMessages();
                }
            }

            createFloatingText(x, y, text, color) {
                // Simple floating text implementation
                // This would create animated floating damage numbers
                console.log(`${text} at (${x}, ${y})`);
            }

            getDistance(entity1, entity2) {
                const dx = entity1.x - entity2.x;
                const dy = entity1.y - entity2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            // Optimize UI sizes for different screen sizes
            optimizeUIForDevice() {
                if (!this.isMobile) return;

                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const isLandscape = screenWidth > screenHeight;

                if (isLandscape) {
                    // Landscape mode optimizations
                    const joystick = document.getElementById('joystick');
                    const attackBtn = document.getElementById('mobileAttackBtn');
                    const targetBtn = document.getElementById('mobileTargetBtn');

                    // Adjust sizes based on screen size
                    if (screenWidth < 600) {
                        // Small screens (phones)
                        joystick.style.width = '80px';
                        joystick.style.height = '80px';
                        attackBtn.style.width = '60px';
                        attackBtn.style.height = '60px';
                        targetBtn.style.width = '45px';
                        targetBtn.style.height = '45px';
                    } else if (screenWidth < 900) {
                        // Medium screens (small tablets)
                        joystick.style.width = '90px';
                        joystick.style.height = '90px';
                        attackBtn.style.width = '65px';
                        attackBtn.style.height = '65px';
                        targetBtn.style.width = '50px';
                        targetBtn.style.height = '50px';
                    }

                    // Adjust positioning for safe areas (notches, etc.)
                    const mobileControls = document.getElementById('mobileControls');
                    const mobileActions = document.getElementById('mobileActionButtons');
                    
                    // Add safe area padding
                    mobileControls.style.paddingLeft = 'env(safe-area-inset-left, 20px)';
                    mobileActions.style.paddingRight = 'env(safe-area-inset-right, 20px)';
                }

                // Add haptic feedback if available
                this.setupHapticFeedback();
            }

            setupHapticFeedback() {
                // Add vibration feedback for mobile interactions
                if (navigator.vibrate && this.isMobile) {
                    const attackBtn = document.getElementById('mobileAttackBtn');
                    const targetBtn = document.getElementById('mobileTargetBtn');

                    attackBtn.addEventListener('touchstart', () => {
                        navigator.vibrate(50); // Short vibration for attack
                    });

                    targetBtn.addEventListener('touchstart', () => {
                        navigator.vibrate(25); // Shorter vibration for target
                    });
                }
            }

            // Game loop
            startGameLoop() {
                let lastTime = 0;
                
                const gameLoop = (currentTime) => {
                    const deltaTime = currentTime - lastTime;
                    lastTime = currentTime;
                    
                    this.update(deltaTime);
                    this.render();
                    
                    requestAnimationFrame(gameLoop);
                };
                
                requestAnimationFrame(gameLoop);
            }
        }

        // Global functions for UI controls
        function toggleInventory() {
            if (window.game) {
                window.game.toggleInventory();
            }
        }

        function toggleSettings() {
            if (window.game) {
                window.game.toggleSettings();
            }
        }

        function toggleGuild() {
            if (window.game) {
                window.game.toggleGuild();
            }
        }

        function switchChatTab(tabName) {
            if (window.game) {
                window.game.switchChatTab(tabName);
            }
        }

        function sendChatMessage() {
            if (window.game) {
                window.game.sendChatMessage();
            }
        }

        function addGuildMember() {
            if (window.game) {
                window.game.addGuildMember();
            }
        }

        function updateSetting(elementId, value) {
            if (window.game) {
                window.game.updateSetting(elementId, value);
            }
        }

        // Start the game when page loads
        window.addEventListener('load', () => {
            window.game = new NosTaleGame();
        });
    </script>
</body>
</html>
